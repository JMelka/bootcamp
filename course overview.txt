
Course overview


General:

    version control with Git

    Javascript

    async API's, Promises

    Test-Driven Development, Mocha


Back end:

    Node, NPM

    SQLite

    HTTP, RESTful API's

    microservices

    Docker containers

    Continuous Integration with Jenkins


Front end:

    HTML, CSS

    DOM methods

    React + Redux

    Angular 1.x


Projects (tentative):

    Twitter clone

    Instagram clone

    Reddit clone

    Slack clone

    final project


Tuesday, Sept. 6th


set up slack accounts

install git, slack, firefox, chrome, postman for chrome, Sqlite manager for firefox

set up github accounts

Git data model and basic commands    

demo Gitk and other git visualization tools

install Node

`npm init` and `npm install`

    Javascript functions

    Javascript expressions, statements, arrays, objects

    install Visual Studio Code

    debugging with VSC

    getting console input with prompt-sync package

    console-based number-guessing game

    console-based rock-paper-scissors game

    create a JS class: Stack exercise

testing with Mocha


Wednesday, Sept. 7th


talk about testing: unit testing, system testing, mocking/stubs, dependency injection

Clean code talks: Unit Testing

Clean code talks: Dependency Injection

http://rbcs-us.com/documents/Why-Most-Unit-Testing-is-Waste.pdf

closures

arrow functions

for-in loops, for-of loops

new operator

variadic functions with arguments array and ...param

exceptions

node thread model

callbacks

reading / writing files sync

reading / writing files async

node streams

promises

testing async with mocha and chai-as-promised

SQLite3 for Node

    RESTful API’s

    Microservices (talk by Martin Fowler)

https://en.wikipedia.org/wiki/Microservices

    microservices vs monolithic SOA:

    pro: more flexible deployment / scaling

    pro: get away from heavy-weight dependencies, overly-prescriptive frameworks

    pro: cuts down friction in large organizations

    pro: get away from single-language, -platform dependence

    pro: embrace component failure / redundancy


    con: more network overhead

    con: consistency / coherence problems

    con: if you get too fine-grained, the services often get too abstract

    con: adds unnecessary indirection / fracturing for small teams    

    con: end up with large system composed out of excessive number of languages/platforms

    con: constructing out of smaller pieces may require more glue

    con: embrace component failure / redundancy: tolerating/hiding bugs that should be fixed

    con: how do I debug across separate services?

    con: https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing


Thursday, Sept. 8th


Project: Twitter clone back end


Friday, Sept. 9th


continue Twitter project

Docker containers

https://nodejs.org/en/docs/guides/nodejs-docker-webapp/


Monday, Sept. 12th


Using Postman

HTML, CSS

    DOM methods



Tuesday, Sept. 13th


functional purity

Immutable.js

Array methods

Lodash

React


Wednesday, Sept. 14th


Redux


Thursday, Sept. 15th


    Hot reloading with webpack

Git branching


Friday, Sept. 16th


    Dependency Injection

    Hooking up Redux to React


Monday, Sept. 19th


    Angular: 50 examples (up through example 31)

    Angular concepts: DI, scopes, modules, controllers, filters


Tuesday, Sept. 20th


    Angular: 50 examples (complete)

    Angular services

    Routing with ngRoute


Wednesday, Sept. 21st


    Angular: structuring controllers and services

Angular events

continuous integration Jenkins

Starting final projects




JS functions and closures:

https://gist.github.com/BrianWill/ba9addaf887970e4f9c38cde905eae05


JS expressions, variables, arrays, objects

https://gist.github.com/BrianWill/6be0ab040e44974fc865a0c9f7f348ac


These sites offer interactive online tutorials / courses covering JS and other topics:

http://codeschool.com/   

http://codeacademy.com/

